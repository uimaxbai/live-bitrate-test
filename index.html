<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>stupid bitrate thing</title>
    <script src="coi-serviceworker.min.js"></script>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
    <style>
      body {
        background: #1a1a1a;
        color: #fff;
        font-family: system-ui, -apple-system, sans-serif;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .container {
        max-width: 800px;
        width: 100%;
      }

      .vis-wrapper {
        position: relative;
        height: 160px;
        background: #000;
        border: 1px solid #444;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 20px;
      }
      canvas {
        width: 100%;
        height: 100%;
      }

      .controls {
        background: #2d2d2d;
        padding: 25px;
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
      }

      .transport {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      #play-btn {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: none;
        background: #00ff9d;
        color: #000;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.1s, background 0.2s;
      }
      #play-btn:hover {
        background: #00cc7d;
        transform: scale(1.05);
      }
      #play-btn:active {
        transform: scale(0.95);
      }
      #play-btn:disabled {
        background: #444;
        color: #666;
        cursor: not-allowed;
        transform: none;
      }

      .slider-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      .time-display {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #888;
        margin-bottom: 5px;
        font-weight: bold;
      }
      input[type="range"] {
        width: 100%;
        accent-color: #00ff9d;
        cursor: pointer;
      }

      .stats-row {
        display: flex;
        justify-content: space-between;
        background: #222;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        color: #aaa;
        border: 1px solid #333;
      }
      .stats-row strong {
        color: #fff;
        margin-left: 5px;
      }

      .settings-row {
        display: flex;
        flex-direction: column;
        background: #222;
        padding: 15px;
        border-radius: 6px;
        gap: 15px;
      }

      .format-selector {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        font-size: 13px;
        color: #ccc;
      }
      .format-selector label {
        display: flex;
        align-items: center;
        gap: 5px;
        cursor: pointer;
      }
      .format-selector input[type="radio"] {
        accent-color: #00ff9d;
      }

      /* PRESET PILLS STYLES */
      .presets-wrapper {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 5px;
        padding-bottom: 15px;
        border-bottom: 1px solid #333;
      }

      .preset-pill {
        background: #333;
        border: 1px solid #444;
        color: #bbb;
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
        font-weight: 500;
      }

      .preset-pill:hover {
        border-color: #00ff9d;
        color: #fff;
        transform: translateY(-1px);
        background: #3a3a3a;
      }

      .preset-pill.active {
        background: #00ff9d;
        color: #000;
        border-color: #00ff9d;
        font-weight: bold;
        box-shadow: 0 0 10px rgba(0, 255, 157, 0.2);
      }

      .quality-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-top: 5px;
      }
      .bitrate-group {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 1;
        margin-right: 20px;
      }
      .bitrate-val {
        color: #00ff9d;
        font-weight: bold;
        min-width: 70px;
        text-align: right;
        font-size: 13px;
      }

      .btn-secondary {
        padding: 8px 16px;
        background: #444;
        border: none;
        color: #fff;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        font-weight: bold;
        text-transform: uppercase;
      }
      .btn-secondary:hover {
        background: #555;
      }
      .btn-secondary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .file-area {
        margin-top: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      #loader {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 10px;
        color: #00ff9d;
        font-weight: bold;
        display: none;
        text-transform: uppercase;
        letter-spacing: 1px;
        background: rgba(0, 0, 0, 0.7);
        padding: 4px 8px;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="vis-wrapper">
        <canvas id="spectrogram"></canvas>
        <div id="loader">PROCESSING...</div>
      </div>

      <audio
        id="audio-player"
        crossorigin="anonymous"
        style="display: none"
      ></audio>

      <div class="controls">
        <div class="transport">
          <button id="play-btn" disabled>▶</button>
          <div class="slider-container">
            <div class="time-display">
              <span id="current-time">0:00</span>
              <span id="total-time">0:00</span>
            </div>
            <input
              type="range"
              id="seek-slider"
              min="0"
              max="100"
              value="0"
              disabled
            />
          </div>
        </div>

        <div class="settings-row">
          <div class="format-selector">
            <label
              ><input type="radio" name="fmt" value="opus" checked />
              Opus</label
            >
            <label><input type="radio" name="fmt" value="mp3" /> MP3</label>
            <label><input type="radio" name="fmt" value="aac" /> AAC</label>
            <label
              ><input type="radio" name="fmt" value="ogg" /> Ogg (Vorbis)</label
            >
            <label><input type="radio" name="fmt" value="flac" /> FLAC</label>
            <label
              ><input type="radio" name="fmt" value="codec2" /> Codec 2</label
            >
          </div>

          <div class="stats-row">
            <span>Original Size: <strong id="size-orig">0.0 MB</strong></span>
            <span>Est. Output Size: <strong id="size-est">0.0 MB</strong></span>
          </div>

          <div id="presets-container" class="presets-wrapper"></div>

          <div class="quality-row">
            <div class="bitrate-group">
              <span id="quality-label" style="color: #888; font-size: 12px"
                >Bitrate</span
              >
              <input
                type="range"
                id="bitrate-slider"
                min="4"
                max="510"
                value="128"
                step="2"
                disabled
              />
              <span class="bitrate-val" id="bitrate-display">128k</span>
            </div>
            <button class="btn-secondary" id="btn-full" disabled>
              Download Full
            </button>
          </div>
        </div>
      </div>

      <div class="file-area">
        <input
          type="file"
          id="uploader"
          accept=".flac,.wav,.mp3"
          style="color: #666"
        />
        <button class="btn-secondary" id="btn-example">
          Load Example File
        </button>
      </div>
    </div>

    <script>
      const { createFFmpeg, fetchFile } = FFmpeg;
      const PREVIEW_DURATION = 10;
      // We use a specific build of FFmpeg that includes libcodec2
      const ffmpeg = createFFmpeg({
        log: true,
        corePath:
          "https://cdn.jsdelivr.net/npm/@uimaxbai/ffmpeg-core-codec2@0.11.3/dist/ffmpeg-core.js",
      });

      // --- Configuration ---

      const PRESETS = {
        opus: [
          { label: "Exp. Min", value: 4 },
          { label: "Speech Min", value: 6 },
          { label: "VOIP", value: 16 },
          { label: "Radio", value: 32 },
          { label: "Discord", value: 64 },
          { label: "Spotify High", value: 160 },
          { label: "Transparent", value: 192 },
        ],
        mp3: [
          { label: "Potato Mic", value: 32 },
          { label: "FM Radio", value: 96 },
          { label: "Standard", value: 128 },
          { label: "High", value: 192 },
          { label: "Extreme", value: 320 },
        ],
        aac: [
          { label: "HE-AACv2", value: 32 },
          { label: "Podcast", value: 64 },
          { label: "YouTube", value: 128 },
          { label: "iTunes Plus", value: 256 },
        ],
        ogg: [
          { label: "Low BW", value: 48 },
          { label: "Standard", value: 112 },
          { label: "High", value: 192 },
        ],
        flac: [
          { label: "Fastest", value: 0 },
          { label: "Default", value: 5 },
          { label: "Max Comp", value: 12 },
        ],
        codec2: [
          { label: "700 bps", value: 0 },
          { label: "1200 bps", value: 1 },
          { label: "1300 bps", value: 2 },
          { label: "1400 bps", value: 3 },
          { label: "1600 bps", value: 4 },
          { label: "2400 bps", value: 5 },
          { label: "3200 bps", value: 6 },
        ],
      };

      const CODEC2_MODES = [700, 1200, 1300, 1400, 1600, 2400, 3200];

      const CODEC_CONFIG = {
        opus: {
          min: 4,
          max: 510,
          step: 2,
          default: 128,
          label: "Bitrate",
          unit: "k",
        },
        mp3: {
          min: 8,
          max: 320,
          step: 2,
          default: 128,
          label: "Bitrate",
          unit: "k",
        },
        aac: {
          min: 4,
          max: 320,
          step: 2,
          default: 128,
          label: "Bitrate",
          unit: "k",
        },
        ogg: {
          min: 48,
          max: 500,
          step: 2,
          default: 128,
          label: "Bitrate",
          unit: "k",
        },
        flac: {
          min: 0,
          max: 12,
          step: 1,
          default: 5,
          label: "Compression",
          unit: "Lvl",
        },
        codec2: {
          min: 0,
          max: 6,
          step: 1,
          default: 4,
          label: "Mode",
          unit: "mode",
        },
      };

      let state = {
        file: null,
        duration: 0,
        currentStartTime: 0,
        nextChunkData: null,
        isDragging: false,
        isProcessing: false,
        isPreloading: false,
        format: "opus",
        fileName: "audio",
      };

      let ffmpegQueue = Promise.resolve();

      function queueFFmpegTask(task) {
        ffmpegQueue = ffmpegQueue.then(task).catch((e) => {
          console.error("FFmpeg task error:", e);
        });
        return ffmpegQueue;
      }

      const ui = {
        playBtn: document.getElementById("play-btn"),
        seekSlider: document.getElementById("seek-slider"),
        currTime: document.getElementById("current-time"),
        totalTime: document.getElementById("total-time"),
        bitrateSlider: document.getElementById("bitrate-slider"),
        bitrateDisplay: document.getElementById("bitrate-display"),
        qualityLabel: document.getElementById("quality-label"),
        sizeOrig: document.getElementById("size-orig"),
        sizeEst: document.getElementById("size-est"),
        btnFull: document.getElementById("btn-full"),
        btnExample: document.getElementById("btn-example"),
        audio: document.getElementById("audio-player"),
        loader: document.getElementById("loader"),
        uploader: document.getElementById("uploader"),
        formats: document.querySelectorAll('input[name="fmt"]'),
        presetsContainer: document.getElementById("presets-container"),
      };

      // --- Rendering Presets ---

      function renderPresets() {
        ui.presetsContainer.innerHTML = "";
        const currentPresets = PRESETS[state.format];
        if (!currentPresets) return;

        currentPresets.forEach((p) => {
          const btn = document.createElement("button");
          btn.className = "preset-pill";

          if (state.format === "codec2") {
            btn.innerText = p.label;
          } else if (state.format === "flac") {
            btn.innerText = `Lvl ${p.value} • ${p.label}`;
          } else {
            btn.innerText = `${p.value}k • ${p.label}`;
          }

          if (parseInt(ui.bitrateSlider.value) === p.value) {
            btn.classList.add("active");
          }

          btn.onclick = async () => {
            document
              .querySelectorAll(".preset-pill")
              .forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");

            ui.bitrateSlider.value = p.value;
            updateBitrateDisplay();
            updateStats();

            if (state.file) {
              state.nextChunkData = null;
              state.currentStartTime =
                state.currentStartTime + ui.audio.currentTime;
              await playCurrentChunk();
            }
          };

          ui.presetsContainer.appendChild(btn);
        });
      }

      renderPresets();

      // --- Event Listeners ---

      ui.playBtn.addEventListener("click", () => {
        initVisualizer();
        if (ui.audio.paused) {
          ui.audio.play();
          ui.playBtn.innerText = "❚❚";
        } else {
          ui.audio.pause();
          ui.playBtn.innerText = "▶";
        }
      });

      ui.audio.addEventListener("play", () => {
        if (visInitialized) drawVisualizer();
      });

      ui.audio.addEventListener("timeupdate", () => {
        if (state.isDragging || state.isProcessing) return;
        const realTime = state.currentStartTime + ui.audio.currentTime;
        ui.seekSlider.value = realTime;
        ui.currTime.innerText = formatTime(realTime);
      });

      ui.audio.addEventListener("ended", async () => {
        const expectedNextTime = state.currentStartTime + PREVIEW_DURATION;
        if (expectedNextTime >= state.duration) {
          ui.playBtn.innerText = "▶";
          ui.seekSlider.value = state.duration;
          return;
        }
        if (
          state.nextChunkData &&
          state.nextChunkData.startTime === expectedNextTime
        ) {
          playBlob(state.nextChunkData.url, expectedNextTime);
          state.nextChunkData = null;
          schedulePreload(expectedNextTime + PREVIEW_DURATION);
        } else {
          state.currentStartTime = expectedNextTime;
          await playCurrentChunk();
        }
      });

      ui.seekSlider.addEventListener("input", (e) => {
        state.isDragging = true;
        ui.currTime.innerText = formatTime(e.target.value);
      });

      ui.seekSlider.addEventListener("change", async (e) => {
        state.isDragging = false;
        state.nextChunkData = null;
        state.currentStartTime = parseFloat(e.target.value);
        await playCurrentChunk();
      });

      ui.formats.forEach((radio) => {
        radio.addEventListener("change", async (e) => {
          const newFormat = e.target.value;
          state.format = newFormat;

          const newConf = CODEC_CONFIG[newFormat];
          ui.bitrateSlider.min = newConf.min;
          ui.bitrateSlider.max = newConf.max;
          ui.bitrateSlider.step = newConf.step;
          ui.bitrateSlider.value = newConf.default;
          ui.qualityLabel.innerText = newConf.label;

          renderPresets();
          updateBitrateDisplay();
          updateStats();

          if (state.file) {
            state.nextChunkData = null;
            state.currentStartTime =
              state.currentStartTime + ui.audio.currentTime;
            await playCurrentChunk();
          }
        });
      });

      function updateStats() {
        if (!state.file) return;
        const origMB = state.file.size / (1024 * 1024);
        ui.sizeOrig.innerText = `${origMB.toFixed(2)} MB`;

        if (state.format === "flac") {
          ui.sizeEst.innerText = "Variable";
          return;
        }

        const duration = state.duration;
        let estimatedBytes = 0;

        if (state.format === "codec2") {
          const modeIndex = parseInt(ui.bitrateSlider.value);
          const bitrate = CODEC2_MODES[modeIndex];
          estimatedBytes = (bitrate * duration) / 8;
        } else {
          const bitrate = parseInt(ui.bitrateSlider.value);
          estimatedBytes = (bitrate * 1000 * duration) / 8;
        }

        const estimatedMB = estimatedBytes / (1024 * 1024);
        ui.sizeEst.innerText = `~${estimatedMB.toFixed(2)} MB`;
      }

      function updateBitrateDisplay() {
        const conf = CODEC_CONFIG[state.format];
        const val = ui.bitrateSlider.value;

        if (state.format === "codec2") {
          const bitrate = CODEC2_MODES[parseInt(val)];
          ui.bitrateDisplay.innerText = `${bitrate} bps`;
        } else if (conf.unit === "Lvl") {
          ui.bitrateDisplay.innerText = "Lvl " + val;
        } else {
          ui.bitrateDisplay.innerText = val + "k";
        }
      }

      ui.bitrateSlider.addEventListener("input", () => {
        updateBitrateDisplay();
        updateStats();
        document
          .querySelectorAll(".preset-pill")
          .forEach((b) => b.classList.remove("active"));
      });

      ui.bitrateSlider.addEventListener("change", async () => {
        if (state.file) {
          state.currentStartTime =
            state.currentStartTime + ui.audio.currentTime;
          state.nextChunkData = null;
          await playCurrentChunk();
        }
      });

      // --- File Loading ---

      async function downloadFileChunked(url) {
        const headRes = await fetch(url, { method: "HEAD", mode: "cors" });
        const size = parseInt(headRes.headers.get("content-length") || "0");

        if (!size) {
          const res = await fetch(url, { mode: "cors" });
          return await res.blob();
        }

        const CHUNK_SIZE = 5 * 1024 * 1024;
        const chunks = [];
        let loaded = 0;

        ui.loader.innerText = "0%";
        ui.loader.style.display = "block";

        while (loaded < size) {
          const end = Math.min(loaded + CHUNK_SIZE, size) - 1;
          const rangeVal = `bytes=${loaded}-${end}`;

          const chunkRes = await fetch(url, {
            headers: { Range: rangeVal },
            mode: "cors",
          });

          if (!chunkRes.ok && chunkRes.status !== 206) {
            throw new Error("Download failed at chunk " + rangeVal);
          }

          const chunkBlob = await chunkRes.blob();
          chunks.push(chunkBlob);
          loaded += chunkBlob.size;

          const percent = Math.floor((loaded / size) * 100);
          ui.loader.innerText = `DL: ${percent}%`;
        }

        return new Blob(chunks);
      }

      ui.uploader.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        loadAudioFile(file, file.name);
      });

      ui.btnExample.addEventListener("click", async () => {
        initVisualizer();
        ui.loader.innerText = "STARTING...";
        ui.loader.style.display = "block";
        ui.btnExample.disabled = true;

        try {
          const url = "https://cdn.binimum.org/music/example.flac";
          const blob = await downloadFileChunked(url);
          blob.name = "example.flac";
          await loadAudioFile(blob, "example.flac");
        } catch (e) {
          console.error(e);
          alert("Error loading example: " + e.message);
        } finally {
          ui.btnExample.disabled = false;
          ui.loader.style.display = "none";
        }
      });

      async function loadAudioFile(fileBlob, fileName) {
        state.file = fileBlob;
        state.fileName = fileName;

        const tempAudio = new Audio(URL.createObjectURL(fileBlob));
        tempAudio.addEventListener("loadedmetadata", async () => {
          state.duration = tempAudio.duration;
          ui.seekSlider.max = state.duration;
          ui.totalTime.innerText = formatTime(state.duration);

          ui.seekSlider.disabled = false;
          ui.bitrateSlider.disabled = false;
          ui.playBtn.disabled = false;
          ui.btnFull.disabled = false;

          updateStats();

          if (!ffmpeg.isLoaded()) await ffmpeg.load();

          ui.loader.innerText = "PREPARING FILE...";
          ui.loader.style.display = "block";

          try {
            ffmpeg.FS("unlink", "input.flac");
          } catch (e) {}
          ffmpeg.FS("writeFile", "input.flac", await fetchFile(fileBlob));

          state.currentStartTime = 0;
          state.nextChunkData = null;
          await playCurrentChunk();
        });
      }

      // --- Transcoding Logic ---

      async function transcodeSegment(startTime, duration) {
        return queueFFmpegTask(async () => {
          const quality = ui.bitrateSlider.value;

          // --- CODEC 2 FIX ---
          if (state.format === "codec2") {
            const modeIndex = parseInt(quality);
            const bitrate = CODEC2_MODES[modeIndex];
            const tempC2 = `temp_${Math.floor(startTime)}.c2`;
            const outWav = `out_${Math.floor(startTime)}.wav`;

            try {
              ffmpeg.FS("unlink", tempC2);
            } catch (e) {}
            try {
              ffmpeg.FS("unlink", outWav);
            } catch (e) {}

            await ffmpeg.run(
              "-ss",
              startTime.toString(),
              "-t",
              duration.toString(),
              "-i",
              "input.flac",
              "-ar",
              "8000",
              "-ac",
              "1",
              "-c:a",
              "codec2",
              // CHANGED: Use -mode instead of -b:a for Codec 2
              "-mode",
              bitrate == 700 ? "700C" : bitrate.toString(),
              tempC2
            );

            await ffmpeg.run("-i", tempC2, "-c:a", "pcm_s16le", outWav);

            const data = ffmpeg.FS("readFile", outWav);
            const blob = new Blob([data.buffer], { type: "audio/wav" });

            try {
              ffmpeg.FS("unlink", tempC2);
            } catch (e) {}
            try {
              ffmpeg.FS("unlink", outWav);
            } catch (e) {}

            return URL.createObjectURL(blob);
          }

          // Standard codecs
          const ext = state.format === "opus" ? "ogg" : state.format;
          const outName = `part_${Math.floor(startTime)}.${ext}`;

          try {
            ffmpeg.FS("unlink", outName);
          } catch (e) {}

          const args = [
            "-ss",
            startTime.toString(),
            "-t",
            duration.toString(),
            "-i",
            "input.flac",
          ];

          switch (state.format) {
            case "mp3":
              args.push("-c:a", "libmp3lame", "-b:a", `${quality}k`);
              break;
            case "aac":
              args.push("-c:a", "aac", "-b:a", `${quality}k`);
              break;
            case "ogg":
              args.push("-c:a", "libvorbis", "-b:a", `${quality}k`);
              break;
            case "opus":
              args.push("-c:a", "libopus", "-b:a", `${quality}k`);
              break;
            case "flac":
              args.push("-c:a", "flac", "-compression_level", quality);
              break;
          }
          args.push(outName);

          await ffmpeg.run(...args);

          const data = ffmpeg.FS("readFile", outName);

          let mime = "audio/mpeg";
          if (state.format === "opus") mime = "audio/ogg; codecs=opus";
          if (state.format === "ogg") mime = "audio/ogg";
          if (state.format === "flac") mime = "audio/flac";
          if (state.format === "aac") mime = "audio/aac";

          const blob = new Blob([data.buffer], { type: mime });
          try {
            ffmpeg.FS("unlink", outName);
          } catch (e) {}

          return URL.createObjectURL(blob);
        });
      }

      async function playCurrentChunk() {
        if (state.isProcessing) return;
        state.isProcessing = true;
        ui.loader.innerText = "PROCESSING...";
        ui.loader.style.display = "block";
        ui.playBtn.disabled = true;

        ui.audio.pause();

        try {
          const url = await transcodeSegment(
            state.currentStartTime,
            PREVIEW_DURATION
          );
          playBlob(url, state.currentStartTime);
          schedulePreload(state.currentStartTime + PREVIEW_DURATION);
        } catch (e) {
          console.error(e);
        } finally {
          state.isProcessing = false;
          ui.loader.style.display = "none";
          ui.playBtn.disabled = false;
        }
      }

      function schedulePreload(startTime) {
        if (startTime >= state.duration || state.isPreloading) return;
        state.isPreloading = true;

        transcodeSegment(startTime, PREVIEW_DURATION)
          .then((url) => {
            state.nextChunkData = { url, startTime };
          })
          .catch((e) => {
            console.log("Preload failed", e);
          })
          .finally(() => {
            state.isPreloading = false;
          });
      }

      function playBlob(url, realStartTime) {
        ui.audio.src = url;
        ui.audio.currentTime = 0;
        state.currentStartTime = realStartTime;
        ui.playBtn.innerText = "❚❚";
        ui.audio.play().catch((e) => console.log("Playback interrupted", e));
      }

      // --- Visualizer ---
      let audioCtx,
        analyser,
        sourceNode,
        visCtx,
        visCanvas,
        tempCanvas,
        tempCtx;
      let visInitialized = false;
      let isDrawing = false;

      function initVisualizer() {
        if (visInitialized) {
          if (audioCtx.state === "suspended") audioCtx.resume();
          return;
        }

        visInitialized = true;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;

        sourceNode = audioCtx.createMediaElementSource(ui.audio);
        sourceNode.connect(analyser);
        analyser.connect(audioCtx.destination);

        visCanvas = document.getElementById("spectrogram");
        visCtx = visCanvas.getContext("2d", { alpha: false });

        tempCanvas = document.createElement("canvas");
        tempCtx = tempCanvas.getContext("2d", { alpha: false });

        const w = visCanvas.offsetWidth;
        const h = visCanvas.offsetHeight;
        visCanvas.width = w;
        visCanvas.height = h;
        tempCanvas.width = w;
        tempCanvas.height = h;

        drawVisualizer();
      }

      function drawVisualizer() {
        if (isDrawing) return;
        isDrawing = true;

        function loop() {
          if (ui.audio.paused && !state.isProcessing) {
            isDrawing = false;
            return;
          }
          requestAnimationFrame(loop);

          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          analyser.getByteFrequencyData(dataArray);

          tempCtx.drawImage(visCanvas, 0, 0);
          visCtx.drawImage(tempCanvas, -1, 0);

          const x = visCanvas.width - 1;
          const h = visCanvas.height;
          visCtx.fillStyle = "#000";
          visCtx.fillRect(x, 0, 1, h);

          for (let i = 0; i < bufferLength; i++) {
            const value = dataArray[i];
            if (value === 0) continue;
            const y = h - Math.floor((i / bufferLength) * h);
            visCtx.fillStyle = `hsl(${270 - (value / 255) * 270}, 100%, 50%)`;
            visCtx.fillRect(x, y, 1, 2);
          }
        }
        loop();
      }

      // --- Full Download ---
      ui.btnFull.addEventListener("click", async () => {
        if (state.isProcessing) return;
        state.isProcessing = true;
        ui.loader.innerText = "RENDERING FULL...";
        ui.loader.style.display = "block";

        try {
          await queueFFmpegTask(async () => {
            const quality = ui.bitrateSlider.value;
            let ext = state.format === "opus" ? "ogg" : state.format;
            let outName = `full_render.${ext}`;

            const args = ["-i", "input.flac"];

            // --- CODEC 2 FIX (Download Full) ---
            if (state.format === "codec2") {
              const modeIndex = parseInt(quality);
              const bitrate = CODEC2_MODES[modeIndex];
              ext = "c2";
              outName = "full_render.c2";
              args.push(
                "-ar",
                "8000",
                "-ac",
                "1",
                "-c:a",
                "codec2",
                // CHANGED: Use -mode instead of -b:a
                "-mode",
                bitrate == 700 ? "700C" : bitrate.toString()
              );
            } else {
              switch (state.format) {
                case "mp3":
                  args.push("-c:a", "libmp3lame", "-b:a", `${quality}k`);
                  break;
                case "aac":
                  args.push("-c:a", "aac", "-b:a", `${quality}k`);
                  break;
                case "ogg":
                  args.push("-c:a", "libvorbis", "-b:a", `${quality}k`);
                  break;
                case "opus":
                  args.push("-c:a", "libopus", "-b:a", `${quality}k`);
                  break;
                case "flac":
                  args.push("-c:a", "flac", "-compression_level", quality);
                  break;
              }
            }
            args.push(outName);

            await ffmpeg.run(...args);

            const data = ffmpeg.FS("readFile", outName);
            const blob = new Blob([data.buffer], {
              type: "application/octet-stream",
            });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = `${state.fileName.replace(/\.[^/.]+$/, "")}_${
              state.format === "codec2"
                ? CODEC2_MODES[quality] + "bps"
                : quality + "k"
            }.${ext}`;
            a.click();

            ffmpeg.FS("unlink", outName);
          });
        } catch (e) {
          console.error(e);
        } finally {
          state.isProcessing = false;
          ui.loader.style.display = "none";
        }
      });

      function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, "0")}`;
      }
    </script>
  </body>
</html>
